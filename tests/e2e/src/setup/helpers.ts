/**
 * Shared E2E test helpers.
 *
 * Provides utilities for running CLI commands, daemon interaction,
 * OS user/group checks, and more.
 */

import { execSync, execFileSync } from 'node:child_process';
import { readFileSync, existsSync } from 'node:fs';
import { resolve } from 'node:path';

const PREFIX_FILE = '/tmp/agenshield-e2e-prefix.txt';
const ROOT_DIR = resolve(__dirname, '../../../..');
const CLI_PATH = resolve(ROOT_DIR, 'libs/cli/dist/src/cli.js');
const DEFAULT_DAEMON_PORT = 5200;
const DAEMON_BASE_URL = `http://localhost:${DEFAULT_DAEMON_PORT}`;

export interface ExecResult {
  stdout: string;
  stderr: string;
  exitCode: number;
}

// ─── Prefix ─────────────────────────────────────────────────────────────────

let cachedPrefix: string | null = null;

/**
 * Read the test prefix generated by global-setup.
 */
export function getTestPrefix(): string {
  if (cachedPrefix) return cachedPrefix;
  cachedPrefix = readFileSync(PREFIX_FILE, 'utf-8').trim();
  return cachedPrefix;
}

/**
 * Get the computed agent username for this test run.
 * Matches the naming convention in the setup wizard.
 */
export function getAgentUsername(): string {
  return `${getTestPrefix()}_ash_default_agent`;
}

/**
 * Get the computed broker username for this test run.
 */
export function getBrokerUsername(): string {
  return `${getTestPrefix()}_ash_default_broker`;
}

/**
 * Get the socket group name for this test run.
 */
export function getSocketGroupName(): string {
  return `${getTestPrefix()}_ash_default`;
}

/**
 * Get the workspace group name for this test run.
 */
export function getWorkspaceGroupName(): string {
  return `${getTestPrefix()}_ash_default_workspace`;
}

// ─── Command Execution ──────────────────────────────────────────────────────

/**
 * Run a CLI command (agenshield CLI) and capture output.
 */
export function runCLI(
  args: string,
  options?: { env?: Record<string, string>; timeout?: number }
): ExecResult {
  const cmd = `node ${CLI_PATH} ${args}`;
  return runShell(cmd, options);
}

/**
 * Run a shell command and capture output.
 */
export function runShell(
  cmd: string,
  options?: { env?: Record<string, string>; timeout?: number }
): ExecResult {
  try {
    const stdout = execSync(cmd, {
      encoding: 'utf-8',
      timeout: options?.timeout ?? 60_000,
      cwd: ROOT_DIR,
      env: { ...process.env, ...options?.env },
      stdio: ['pipe', 'pipe', 'pipe'],
    });
    return { stdout, stderr: '', exitCode: 0 };
  } catch (err: unknown) {
    const e = err as { stdout?: string; stderr?: string; status?: number };
    return {
      stdout: e.stdout ?? '',
      stderr: e.stderr ?? '',
      exitCode: e.status ?? 1,
    };
  }
}

/**
 * Run a command as the agent user via sudo -u.
 */
export function runAsAgentUser(
  command: string,
  options?: { timeout?: number }
): ExecResult {
  const agentUser = getAgentUsername();
  return runShell(`sudo -u ${agentUser} ${command}`, options);
}

// ─── Daemon Interaction ─────────────────────────────────────────────────────

/**
 * Wait for the daemon health endpoint to respond successfully.
 */
export async function waitForDaemon(
  port: number = DEFAULT_DAEMON_PORT,
  timeoutMs: number = 15_000
): Promise<boolean> {
  const start = Date.now();
  const url = `http://localhost:${port}/api/health`;

  while (Date.now() - start < timeoutMs) {
    try {
      const res = await fetch(url, { signal: AbortSignal.timeout(2000) });
      if (res.ok) return true;
    } catch {
      // Not ready yet
    }
    await sleep(500);
  }

  return false;
}

/**
 * Wait for the daemon to stop (health endpoint becomes unreachable).
 */
export async function waitForDaemonStop(timeoutMs: number = 15_000): Promise<boolean> {
  const start = Date.now();
  const url = `${DAEMON_BASE_URL}/api/health`;

  while (Date.now() - start < timeoutMs) {
    try {
      await fetch(url, { signal: AbortSignal.timeout(1000) });
      // Still running, wait
      await sleep(500);
    } catch {
      // Connection refused = daemon stopped
      return true;
    }
  }

  return false;
}

/**
 * Make an HTTP request to the daemon API.
 */
export async function daemonAPI(
  method: string,
  path: string,
  body?: unknown
): Promise<{ status: number; data: unknown }> {
  const url = `${DAEMON_BASE_URL}/api${path}`;
  const opts: RequestInit = {
    method,
    headers: { 'Content-Type': 'application/json' },
    signal: AbortSignal.timeout(10_000),
  };

  if (body !== undefined) {
    opts.body = JSON.stringify(body);
  }

  const res = await fetch(url, opts);
  const data = await res.json();
  return { status: res.status, data };
}

// ─── OS User/Group Checks ───────────────────────────────────────────────────

/**
 * Check if an OS user exists (macOS via dscl).
 */
export function userExists(username: string): boolean {
  if (process.platform !== 'darwin') {
    // Linux fallback: check /etc/passwd
    try {
      execSync(`id ${username}`, { stdio: 'pipe' });
      return true;
    } catch {
      return false;
    }
  }

  try {
    execSync(`dscl . -read /Users/${username}`, { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

/**
 * Check if an OS group exists (macOS via dscl).
 */
export function groupExists(groupName: string): boolean {
  if (process.platform !== 'darwin') {
    try {
      execSync(`getent group ${groupName}`, { stdio: 'pipe' });
      return true;
    } catch {
      return false;
    }
  }

  try {
    execSync(`dscl . -read /Groups/${groupName}`, { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

// ─── Utilities ──────────────────────────────────────────────────────────────

export function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Get the project root directory.
 */
export function getRootDir(): string {
  return ROOT_DIR;
}

/**
 * Get the path to the CLI entry point (built).
 */
export function getCLIPath(): string {
  return CLI_PATH;
}
