/**
 * OpenClaw LaunchDaemon Management
 *
 * Creates and manages macOS LaunchDaemons for OpenClaw daemon and gateway
 * processes, running inside the AgenShield sandbox with intercepted Node.js.
 *
 * Both processes run as the agent user with NODE_OPTIONS set to load the
 * interceptor, ensuring all network and exec operations are monitored.
 */

import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import { execSync } from 'node:child_process';
import { exec } from 'node:child_process';
import { promisify } from 'node:util';
import { hasOpenClawFeature } from '@agenshield/ipc';
import { detectHostOpenClawVersion } from './openclaw-install';

const execAsync = promisify(exec);

// ─── Constants ───────────────────────────────────────────────────────────────

const OPENCLAW_DAEMON_LABEL = 'com.agenshield.openclaw.daemon';
const OPENCLAW_GATEWAY_LABEL = 'com.agenshield.openclaw.gateway';
const OPENCLAW_DAEMON_PLIST = '/Library/LaunchDaemons/com.agenshield.openclaw.daemon.plist';
const OPENCLAW_GATEWAY_PLIST = '/Library/LaunchDaemons/com.agenshield.openclaw.gateway.plist';
const OPENCLAW_LAUNCHER_PATH = '/opt/agenshield/bin/openclaw-launcher.sh';
const BROKER_LABEL = 'com.agenshield.broker';

// ─── Types ───────────────────────────────────────────────────────────────────

export interface OpenClawLaunchConfig {
  agentUsername: string;
  socketGroupName: string;
  agentHome: string;
  socketPath?: string;
  interceptorPath?: string;
  httpPort?: number;
}

export interface OpenClawProcessStatus {
  running: boolean;
  pid?: number;
  lastExitStatus?: number;
}

export interface OpenClawStatus {
  daemon: OpenClawProcessStatus;
  gateway: OpenClawProcessStatus;
}

export interface OpenClawDaemonResult {
  success: boolean;
  message: string;
  error?: Error;
}

// ─── Launcher Script ─────────────────────────────────────────────────────────

/**
 * Generate the openclaw-launcher.sh script content.
 *
 * This script sources NVM, sets up interceptor environment variables,
 * then execs openclaw with the given arguments.
 */
function generateLauncherScript(config: OpenClawLaunchConfig): string {
  const socketPath = config.socketPath || '/var/run/agenshield/agenshield.sock';
  const interceptorPath = config.interceptorPath || '/opt/agenshield/lib/interceptor/register.cjs';
  const httpPort = config.httpPort || 5201;

  return `#!/bin/bash
# OpenClaw Launcher — runs openclaw with AgenShield interceptor
# Generated by AgenShield setup. Do not edit manually.

export HOME="${config.agentHome}"
export NVM_DIR="${config.agentHome}/.nvm"

# Match guarded-shell PATH: wrappers first, then homebrew
export PATH="$HOME/bin:$HOME/homebrew/bin:/usr/bin:/bin:/usr/sbin:/sbin"
export SHELL="/usr/local/bin/guarded-shell"

# Load NVM to get correct node/npm/openclaw in PATH (prepends NVM paths)
NVM_LOADED=false
if [ -s "$NVM_DIR/nvm.sh" ]; then
  source "$NVM_DIR/nvm.sh" 2>/dev/null && NVM_LOADED=true
fi
if [ "$NVM_LOADED" = "false" ]; then
  echo "[AgenShield:PREFLIGHT] WARNING: NVM not loaded (NVM_DIR=$NVM_DIR)" >&2
fi

# Load interceptor via NODE_OPTIONS (deduplicate if already set by plist EnvironmentVariables)
case "\${NODE_OPTIONS:-}" in
  *"register.cjs"*) ;;
  *) export NODE_OPTIONS="--disable-warning=ExperimentalWarning --require ${interceptorPath} \${NODE_OPTIONS:-}" ;;
esac

# AgenShield environment
export AGENSHIELD_SOCKET="${socketPath}"
export AGENSHIELD_HTTP_PORT="${httpPort}"
export AGENSHIELD_INTERCEPT_EXEC=true
export AGENSHIELD_INTERCEPT_HTTP=true
export AGENSHIELD_INTERCEPT_FETCH=true
export AGENSHIELD_INTERCEPT_WS=true
export AGENSHIELD_CONTEXT_TYPE=agent

# Wait for broker socket (up to 30 seconds)
SOCKET_WAIT=0
while [ ! -S "${socketPath}" ] && [ $SOCKET_WAIT -lt 30 ]; do
  sleep 1
  SOCKET_WAIT=$((SOCKET_WAIT + 1))
done
if [ ! -S "${socketPath}" ]; then
  echo "[AgenShield:PREFLIGHT] WARNING: broker socket not found after 30s at ${socketPath}" >&2
fi

# Pre-flight validation
PREFLIGHT_OK=true
[ ! -x "/opt/agenshield/bin/node-bin" ] && echo "[AgenShield:PREFLIGHT] FATAL: node-bin not found at /opt/agenshield/bin/node-bin" >&2 && PREFLIGHT_OK=false
[ ! -f "${interceptorPath}" ] && echo "[AgenShield:PREFLIGHT] FATAL: interceptor not found at ${interceptorPath}" >&2 && PREFLIGHT_OK=false
command -v openclaw &>/dev/null || { echo "[AgenShield:PREFLIGHT] FATAL: openclaw not in PATH (PATH=$PATH)" >&2; PREFLIGHT_OK=false; }
[ -z "$NODE_OPTIONS" ] && echo "[AgenShield:PREFLIGHT] FATAL: NODE_OPTIONS is empty — interceptor will not load" >&2 && PREFLIGHT_OK=false
[ "$PREFLIGHT_OK" = "false" ] && exit 78

exec openclaw "$@"
`;
}

// ─── Plist Generation ────────────────────────────────────────────────────────

/**
 * Generate LaunchDaemon plist for OpenClaw daemon process.
 */
export function generateOpenClawDaemonPlist(config: OpenClawLaunchConfig): string {
  const socketPath = config.socketPath || '/var/run/agenshield/agenshield.sock';
  const interceptorPath = config.interceptorPath || '/opt/agenshield/lib/interceptor/register.cjs';
  const httpPort = config.httpPort || 5201;

  return `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>${OPENCLAW_DAEMON_LABEL}</string>

    <key>ProgramArguments</key>
    <array>
        <string>${OPENCLAW_LAUNCHER_PATH}</string>
        <string>daemon</string>
        <string>run</string>
    </array>

    <key>UserName</key>
    <string>${config.agentUsername}</string>

    <key>GroupName</key>
    <string>${config.socketGroupName}</string>

    <key>EnvironmentVariables</key>
    <dict>
        <key>HOME</key>
        <string>${config.agentHome}</string>
        <key>PATH</key>
        <string>${config.agentHome}/bin:${config.agentHome}/homebrew/bin:/usr/bin:/bin:/usr/sbin:/sbin</string>
        <key>SHELL</key>
        <string>/usr/local/bin/guarded-shell</string>
        <key>NODE_OPTIONS</key>
        <string>--disable-warning=ExperimentalWarning --require ${interceptorPath}</string>
        <key>AGENSHIELD_SOCKET</key>
        <string>${socketPath}</string>
        <key>AGENSHIELD_HTTP_PORT</key>
        <string>${httpPort}</string>
        <key>AGENSHIELD_INTERCEPT_EXEC</key>
        <string>true</string>
        <key>AGENSHIELD_INTERCEPT_HTTP</key>
        <string>true</string>
        <key>AGENSHIELD_INTERCEPT_FETCH</key>
        <string>true</string>
        <key>AGENSHIELD_INTERCEPT_WS</key>
        <string>true</string>
        <key>AGENSHIELD_CONTEXT_TYPE</key>
        <string>agent</string>
    </dict>

    <key>RunAtLoad</key>
    <false/>

    <key>KeepAlive</key>
    <dict>
        <key>OtherJobEnabled</key>
        <dict>
            <key>${BROKER_LABEL}</key>
            <true/>
        </dict>
    </dict>

    <key>ThrottleInterval</key>
    <integer>10</integer>

    <key>StandardOutPath</key>
    <string>/var/log/agenshield/openclaw-daemon.log</string>

    <key>StandardErrorPath</key>
    <string>/var/log/agenshield/openclaw-daemon.error.log</string>

    <key>WorkingDirectory</key>
    <string>${config.agentHome}</string>

    <key>SoftResourceLimits</key>
    <dict>
        <key>NumberOfFiles</key>
        <integer>4096</integer>
    </dict>
</dict>
</plist>
`;
}

/**
 * Generate LaunchDaemon plist for OpenClaw gateway process.
 */
export function generateOpenClawGatewayPlist(config: OpenClawLaunchConfig): string {
  const socketPath = config.socketPath || '/var/run/agenshield/agenshield.sock';
  const interceptorPath = config.interceptorPath || '/opt/agenshield/lib/interceptor/register.cjs';
  const httpPort = config.httpPort || 5201;

  return `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>${OPENCLAW_GATEWAY_LABEL}</string>

    <key>ProgramArguments</key>
    <array>
        <string>${OPENCLAW_LAUNCHER_PATH}</string>
        <string>gateway</string>
        <string>run</string>
    </array>

    <key>UserName</key>
    <string>${config.agentUsername}</string>

    <key>GroupName</key>
    <string>${config.socketGroupName}</string>

    <key>EnvironmentVariables</key>
    <dict>
        <key>HOME</key>
        <string>${config.agentHome}</string>
        <key>PATH</key>
        <string>${config.agentHome}/bin:${config.agentHome}/homebrew/bin:/usr/bin:/bin:/usr/sbin:/sbin</string>
        <key>SHELL</key>
        <string>/usr/local/bin/guarded-shell</string>
        <key>NODE_OPTIONS</key>
        <string>--disable-warning=ExperimentalWarning --require ${interceptorPath}</string>
        <key>AGENSHIELD_SOCKET</key>
        <string>${socketPath}</string>
        <key>AGENSHIELD_HTTP_PORT</key>
        <string>${httpPort}</string>
        <key>AGENSHIELD_INTERCEPT_EXEC</key>
        <string>true</string>
        <key>AGENSHIELD_INTERCEPT_HTTP</key>
        <string>true</string>
        <key>AGENSHIELD_INTERCEPT_FETCH</key>
        <string>true</string>
        <key>AGENSHIELD_INTERCEPT_WS</key>
        <string>true</string>
        <key>AGENSHIELD_CONTEXT_TYPE</key>
        <string>agent</string>
    </dict>

    <key>RunAtLoad</key>
    <false/>

    <key>KeepAlive</key>
    <dict>
        <key>OtherJobEnabled</key>
        <dict>
            <key>${BROKER_LABEL}</key>
            <true/>
        </dict>
    </dict>

    <key>ThrottleInterval</key>
    <integer>10</integer>

    <key>StandardOutPath</key>
    <string>/var/log/agenshield/openclaw-gateway.log</string>

    <key>StandardErrorPath</key>
    <string>/var/log/agenshield/openclaw-gateway.error.log</string>

    <key>WorkingDirectory</key>
    <string>${config.agentHome}</string>

    <key>SoftResourceLimits</key>
    <dict>
        <key>NumberOfFiles</key>
        <integer>4096</integer>
    </dict>
</dict>
</plist>
`;
}

// ─── Installation ────────────────────────────────────────────────────────────

/**
 * Install the openclaw-launcher.sh script to /opt/agenshield/bin/.
 */
export async function installOpenClawLauncher(
  config: OpenClawLaunchConfig
): Promise<OpenClawDaemonResult> {
  try {
    const content = generateLauncherScript(config);

    await execAsync(`sudo tee "${OPENCLAW_LAUNCHER_PATH}" > /dev/null << 'LAUNCHEREOF'
${content}
LAUNCHEREOF`);
    await execAsync(`sudo chmod 755 "${OPENCLAW_LAUNCHER_PATH}"`);
    await execAsync(`sudo chown root:wheel "${OPENCLAW_LAUNCHER_PATH}"`);

    return {
      success: true,
      message: `Launcher script installed at ${OPENCLAW_LAUNCHER_PATH}`,
    };
  } catch (error) {
    return {
      success: false,
      message: `Failed to install launcher: ${(error as Error).message}`,
      error: error as Error,
    };
  }
}

/**
 * Install OpenClaw LaunchDaemon plists and launcher script.
 */
export async function installOpenClawLaunchDaemons(
  config: OpenClawLaunchConfig
): Promise<OpenClawDaemonResult> {
  try {
    // 1. Install launcher script
    const launcherResult = await installOpenClawLauncher(config);
    if (!launcherResult.success) {
      return launcherResult;
    }

    // 2. Ensure log files exist with correct ownership
    const agentUsername = config.agentUsername;
    const socketGroupName = config.socketGroupName;
    await execAsync(`sudo touch /var/log/agenshield/openclaw-gateway.log /var/log/agenshield/openclaw-gateway.error.log`);
    await execAsync(`sudo chown ${agentUsername}:${socketGroupName} /var/log/agenshield/openclaw-gateway.log /var/log/agenshield/openclaw-gateway.error.log`);

    // 3. Remove stale entries
    try {
      await execAsync(`sudo launchctl bootout system/${OPENCLAW_DAEMON_LABEL} 2>/dev/null`);
    } catch { /* not loaded */ }
    try {
      await execAsync(`sudo launchctl bootout system/${OPENCLAW_GATEWAY_LABEL} 2>/dev/null`);
    } catch { /* not loaded */ }

    // 4. Generate and write gateway plist
    const gatewayPlist = generateOpenClawGatewayPlist(config);
    await execAsync(`sudo tee "${OPENCLAW_GATEWAY_PLIST}" > /dev/null << 'PLISTEOF'
${gatewayPlist}
PLISTEOF`);
    await execAsync(`sudo chown root:wheel "${OPENCLAW_GATEWAY_PLIST}"`);
    await execAsync(`sudo chmod 644 "${OPENCLAW_GATEWAY_PLIST}"`);

    // 5. Load gateway plist (but don't start — RunAtLoad is false)
    await execAsync(`sudo launchctl load -w "${OPENCLAW_GATEWAY_PLIST}"`);

    return {
      success: true,
      message: 'OpenClaw LaunchDaemons installed and loaded',
    };
  } catch (error) {
    return {
      success: false,
      message: `Failed to install OpenClaw LaunchDaemons: ${(error as Error).message}`,
      error: error as Error,
    };
  }
}

// ─── Lifecycle Management ────────────────────────────────────────────────────

/**
 * Start OpenClaw daemon and gateway services via launchctl.
 */
export async function startOpenClawServices(): Promise<OpenClawDaemonResult> {
  try {
    // Re-enable the job (may have been disabled by stopOpenClawServices)
    try {
      await execAsync(`sudo launchctl enable system/${OPENCLAW_GATEWAY_LABEL}`);
    } catch { /* may already be enabled */ }
    await execAsync(`sudo launchctl kickstart system/${OPENCLAW_GATEWAY_LABEL}`);
    return {
      success: true,
      message: 'OpenClaw gateway started',
    };
  } catch (error) {
    return {
      success: false,
      message: `Failed to start OpenClaw gateway: ${(error as Error).message}`,
      error: error as Error,
    };
  }
}

/**
 * Stop OpenClaw daemon and gateway services via launchctl.
 */
export async function stopOpenClawServices(): Promise<OpenClawDaemonResult> {
  try {
    // Disable the job first to prevent KeepAlive auto-restart
    try {
      await execAsync(`sudo launchctl disable system/${OPENCLAW_GATEWAY_LABEL}`);
    } catch { /* may already be disabled */ }
    await execAsync(`sudo launchctl kill SIGTERM system/${OPENCLAW_GATEWAY_LABEL}`);
    return {
      success: true,
      message: 'OpenClaw gateway stopped',
    };
  } catch (error) {
    return {
      success: false,
      message: `Failed to stop OpenClaw gateway: ${(error as Error).message}`,
      error: error as Error,
    };
  }
}

/**
 * Restart OpenClaw daemon and gateway services.
 */
export async function restartOpenClawServices(): Promise<OpenClawDaemonResult> {
  try {
    await execAsync(`sudo launchctl kickstart -k system/${OPENCLAW_GATEWAY_LABEL}`);
    return {
      success: true,
      message: 'OpenClaw gateway restarted',
    };
  } catch (error) {
    return {
      success: false,
      message: `Failed to restart OpenClaw gateway: ${(error as Error).message}`,
      error: error as Error,
    };
  }
}

// ─── Status Checking ─────────────────────────────────────────────────────────

/**
 * Parse launchctl list output to extract PID and exit status.
 */
function parseLaunchctlStatus(stdout: string): OpenClawProcessStatus {
  const status: OpenClawProcessStatus = { running: false };

  const lines = stdout.split('\n');
  for (const line of lines) {
    if (line.includes('"PID"')) {
      const match = line.match(/"PID"\s*=\s*(\d+)/);
      if (match) {
        status.pid = parseInt(match[1], 10);
        status.running = true;
      }
    }
    if (line.includes('"LastExitStatus"')) {
      const match = line.match(/"LastExitStatus"\s*=\s*(\d+)/);
      if (match) {
        status.lastExitStatus = parseInt(match[1], 10);
      }
    }
  }

  // Also try the simpler format: PID = N
  if (!status.pid) {
    for (const line of lines) {
      if (line.includes('PID')) {
        const match = line.match(/PID\s*=\s*(\d+)/);
        if (match) {
          status.pid = parseInt(match[1], 10);
          status.running = true;
        }
      }
      if (line.includes('LastExitStatus')) {
        const match = line.match(/LastExitStatus\s*=\s*(\d+)/);
        if (match) {
          status.lastExitStatus = parseInt(match[1], 10);
        }
      }
    }
  }

  return status;
}

/**
 * Get OpenClaw process status (async).
 */
export async function getOpenClawStatus(): Promise<OpenClawStatus> {
  const result: OpenClawStatus = {
    daemon: { running: false },
    gateway: { running: false },
  };

  // Check gateway
  try {
    const { stdout } = await execAsync(`sudo launchctl list ${OPENCLAW_GATEWAY_LABEL} 2>/dev/null`);
    result.gateway = parseLaunchctlStatus(stdout);
    if (!result.gateway.running) {
      result.gateway.running = false;
    }
  } catch {
    // Not loaded or not running
  }

  return result;
}

/**
 * Get OpenClaw process status (sync version for use in buildDaemonStatus).
 */
export function getOpenClawStatusSync(): OpenClawStatus {
  const result: OpenClawStatus = {
    daemon: { running: false },
    gateway: { running: false },
  };

  try {
    const stdout = execSync(`sudo launchctl list ${OPENCLAW_GATEWAY_LABEL} 2>/dev/null`, {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe'],
    });
    result.gateway = parseLaunchctlStatus(stdout);
  } catch { /* not loaded */ }

  return result;
}

/**
 * Get the OpenClaw dashboard URL by reading gateway config from openclaw.json.
 *
 * Constructs the URL from gateway.port and gateway.auth.token fields.
 */
export async function getOpenClawDashboardUrl(): Promise<{ success: boolean; url?: string; error?: string }> {
  try {
    const agentHome = process.env['AGENSHIELD_AGENT_HOME'] || '/Users/ash_default_agent';
    const configPath = path.join(agentHome, '.openclaw', 'openclaw.json');

    let raw: string;
    try {
      raw = await fs.readFile(configPath, 'utf-8');
    } catch (err) {
      if ((err as NodeJS.ErrnoException).code === 'EACCES') {
        // File owned by agent user — read via sudo
        const agentUsername = path.basename(agentHome);
        const { stdout } = await execAsync(
          `sudo -H -u ${agentUsername} cat "${configPath}"`,
          { cwd: '/' }
        );
        raw = stdout;
      } else {
        return { success: false, error: `Cannot read openclaw.json: ${(err as Error).message}` };
      }
    }

    const config = JSON.parse(raw) as {
      gateway?: { port?: number; mode?: string; auth?: { token?: string } };
    };

    const port = config.gateway?.port;
    const token = config.gateway?.auth?.token;
    if (!port || !token) {
      return { success: false, error: 'Gateway port or auth token not found in openclaw.json' };
    }

    const version = detectHostOpenClawVersion();
    const url = hasOpenClawFeature(version, 'hashTokenAuth')
      ? `http://127.0.0.1:${port}/#token=${token}`
      : `http://127.0.0.1:${port}/?token=${token}`;
    return { success: true, url };
  } catch (error) {
    return { success: false, error: `Failed to get dashboard URL: ${(error as Error).message}` };
  }
}

/**
 * Check if OpenClaw LaunchDaemon plists are installed.
 */
export async function isOpenClawInstalled(): Promise<boolean> {
  try {
    await fs.access(OPENCLAW_GATEWAY_PLIST);
    return true;
  } catch {
    return false;
  }
}

/**
 * Uninstall OpenClaw LaunchDaemons.
 */
export async function uninstallOpenClawLaunchDaemons(): Promise<OpenClawDaemonResult> {
  try {
    // Stop services first
    await stopOpenClawServices();

    // Unload
    try {
      await execAsync(`sudo launchctl bootout system/${OPENCLAW_DAEMON_LABEL} 2>/dev/null`);
    } catch { /* not loaded */ }
    try {
      await execAsync(`sudo launchctl bootout system/${OPENCLAW_GATEWAY_LABEL} 2>/dev/null`);
    } catch { /* not loaded */ }

    // Remove plist files
    await execAsync(`sudo rm -f "${OPENCLAW_DAEMON_PLIST}" "${OPENCLAW_GATEWAY_PLIST}"`);

    // Remove launcher script
    await execAsync(`sudo rm -f "${OPENCLAW_LAUNCHER_PATH}"`);

    return {
      success: true,
      message: 'OpenClaw LaunchDaemons uninstalled',
    };
  } catch (error) {
    return {
      success: false,
      message: `Failed to uninstall OpenClaw LaunchDaemons: ${(error as Error).message}`,
      error: error as Error,
    };
  }
}

// Export constants for external use
export {
  OPENCLAW_GATEWAY_LABEL,
  OPENCLAW_DAEMON_PLIST,
  OPENCLAW_GATEWAY_PLIST,
  OPENCLAW_LAUNCHER_PATH,
};
